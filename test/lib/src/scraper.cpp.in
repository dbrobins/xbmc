// Implements xbmc.lib.scraper
//
// *** GENERATED CODE DO NOT EDIT ***
## (applies to the .cpp file, not the .in file...)
//
<%namespace file="defs.mako" import="*"/>

#include "Python.h"
#include "structmember.h"

#include "xbmc.h"
#include "addons/Addon.h"
#include "addons/Scraper.h"
#include "addons/AddonManager.h"
#include "filesystem/FileCurl.h"
#include "video/VideoInfoTag.h"

using namespace std;
using namespace ADDON;

// Empty object
// - used by type container (ptoTyp)
struct EmO
{
  PyObject_HEAD
};

// Python scraper object
struct ScrO
{
  PyObject_HEAD
  ScraperPtr psc;
};

// Python immutable string map
struct MpsO
{
  PyObject_HEAD
  PyObject *pscro;
  InfoMap *pmp;
};

// Python settings object
struct SetO
{
  PyObject_HEAD
  PyObject *pscro;
  SETTINGS *pset;
};

// Python dependencies object
struct DepO
{
  PyObject_HEAD
  PyObject *pscro;
  ADDONDEPS *pdep;
};


// Utility functions

// passed-in object assumed to be zero-initialized already
static void InitPto(PyTypeObject &pto, const char *sName, size_t cb, const char *sDoc)
{
  pto.tp_name = sName;
  pto.tp_basicsize = cb;
  pto.tp_doc = sDoc;
  pto.tp_new = PyType_GenericNew;
  pto.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;
}

// raise Python exception for scraper error
PyObject *PyoRaiseSce(const CScraperError &sce)
{
  //XXX get our own exception
  if (sce.FAborted())
    PyErr_SetString(PyExc_RuntimeError, "scraper aborted");
  else
    PyErr_SetString(PyExc_RuntimeError, "CScraperError");
  return NULL;
}


// Scraper object implementation

static int scr_init(ScrO *pscro, PyObject *args, PyObject *kwds)
{
  // parse arguments: scraper type (Type.T) or name (e.g., "metadata.tvdb.com")
  if (kwds && PyDict_Size(kwds))
  {
    PyErr_SetString(PyExc_TypeError, "unexpected keyword argument");
    return -1;
  }

  TYPE typ = ADDON_UNKNOWN;
  const char *sName = NULL;
  if (!PyArg_ParseTuple(args, "i", &typ))
  {
    if (!PyArg_ParseTuple(args, "s", &sName))
    {
      PyErr_SetString(PyExc_TypeError, "scraper type or name required");
      return -1;
    }
    PyErr_Clear();
  }

  // fetch the addon from the addon manager
  AddonPtr pao;
  if (sName)
  {
    if (!CAddonMgr::Get().GetAddon(sName, pao))
    {
      PyErr_SetString(PyExc_RuntimeError, "scraper not found");
      return -1;
    }
  }
  else if (!CAddonMgr::Get().GetDefault(typ, pao))
  {
    PyErr_SetString(PyExc_RuntimeError, "default scraper unavailable");
    return -1;
  }

  // cast to scraper and store
  pscro->psc = boost::dynamic_pointer_cast<CScraper>(pao);
  return 0;
}

static void scr_dealloc(ScrO *pscro)
{
  pscro->~ScrO();
}

static PyObject *scr_nfo_url(ScrO *pscro, PyObject *ppyo)
{
  // verify and convert passed-in string
  const char *sIn;
  Py_ssize_t cchIn;
  if (PyString_AsStringAndSize(ppyo, (char **)&sIn, &cchIn) < 0)
    return NULL;
  CStdString s(sIn, cchIn);

  try
  {
    CScraperUrl scurl = pscro->psc->NfoUrl(s);
    if (scurl.m_url.empty())
      Py_RETURN_NONE;
    //XXX return a proper object!
    CStdString &sRet = scurl.m_url.begin()->m_url;
    return PyString_FromStringAndSize(sRet, sRet.size());
  }
  catch(const CScraperError &sce)
  {
    return PyoRaiseSce(sce);
  }
}

//XXX need a way to set fcurl (globally, or in the object?)...
//also need a scraper object
//and a scraper exception/abort (two separate Python exceptions?)

static PyMethodDef pmdScr[] = {
  {"nfo_url", (PyCFunction)scr_nfo_url, METH_O,
    "Given the contents of a .nfo file, returns an URL (None if none found)" },

/*
  {"find_movie", (PyCFunction)scr_find_movie, METH_VARARGS,
    "Find a movie given the title; replace special chars if clean is True" },
  {"find_album", (PyCFunction)scr_find_album, METH_VARARGS,
    "Find an album given the title and optional artist" },
  {"find_artist", (PyCFunction)scr_find_artist, METH_O,
    "Find an artist given a name" },

 * XXX really these should be called on the object returned from the above...
 * ... art_details should store the search string on return so it can be autopassed
 * ... they can also be given fcurl and scurl will be implicit from the object
  {"episodes", (PyCFunction)vid_episodes, METH_NOARGS,
    "Get episode list" },
  {"details", (PyCFunction)vid_details, METH_NOARGS,
    "Get video details" },
  {"details", (PyCFunction)alb_details, METH_NOARGS,
    "Get album details" },
  {"details", (PyCFunction)art_details, METH_NOARGS,
    "Get artist details" },
*/
#if 0
  // scraper media functions

  std::vector<CScraperUrl> FindMovie(XFILE::CFileCurl &fcurl,
    const CStdString &sMovie, bool fFirst);
  std::vector<MUSIC_GRABBER::CMusicAlbumInfo> FindAlbum(XFILE::CFileCurl &fcurl,
    const CStdString &sAlbum, const CStdString &sArtist = "");
  std::vector<MUSIC_GRABBER::CMusicArtistInfo> FindArtist(
    XFILE::CFileCurl &fcurl, const CStdString &sArtist);
  EPISODELIST GetEpisodeList(XFILE::CFileCurl &fcurl, const CScraperUrl &scurl);

  bool GetVideoDetails(XFILE::CFileCurl &fcurl, const CScraperUrl &scurl,
    bool fMovie/*else episode*/, CVideoInfoTag &video);
  bool GetAlbumDetails(XFILE::CFileCurl &fcurl, const CScraperUrl &scurl,
    CAlbum &album);
  bool GetArtistDetails(XFILE::CFileCurl &fcurl, const CScraperUrl &scurl,
    const CStdString &sSearch, CArtist &artist);
#endif
  {NULL}  /* Sentinel */
};

<%
add_get('type', 'Type', 'int', "Scraper type, from Type enumeration")
add_get('id', 'ID', 'CStdString', "Scraper id (dotted pseudo-domain)")
add_get('name', 'Name', 'CStdString', "Scraper display name")
add_get('enabled', 'Enabled', 'bool', "True if scraper is currently enabled")
add_get('active', 'IsInUse', 'bool', "True if scraper is currently running")
add_get('ver', 'Version', 'AddonVersion', "Scraper version (NOT COMPARABLE)")
add_get('min_ver', 'MinVersion', 'AddonVersion', "Minimum compatible version")
add_get('summary', 'Summary', 'CStdString', "Scraper summary")
add_get('desc', 'Description', 'CStdString', "Scraper description")
add_get('path', 'Path', 'CStdString', "Path to scraper files")
add_get('profile', 'Profile', 'CStdString', "Path to profile-local data")
add_get('lib_path', 'LibPath', 'CStdString', "Path to addon library")
add_get('changelog', 'ChangeLog', 'CStdString', "Scraper change log")
add_get('fanart', 'FanArt', 'CStdString', "Fan art path")
add_get('author', 'Author', 'CStdString', "Scraper developer")
add_get('icon', 'Icon', 'CStdString', "Path to scraper icon")
add_get('rating', 'Stars', 'int', "Rating (0-5 stars)")
add_get('disclaimer', 'Disclaimer', 'CStdString', "Disclaimer text")
add_get('lang', 'Language', 'CStdString', "Scraper language")
add_get('has_settings', 'HasSettings', 'bool', "True if scraper has custom settings")

# settings can be a dict - but we need to overload stuff
# why aren't HasSettings and GetSettings const? A: because they load settings
#void UpdateSetting(const CStdString& key, const CStdString& value)
#CStdString GetSetting(const CStdString& key)
#void SaveSettings()  // if we allow update, we should allow save...
#
# -- a std::map str -> str; should also be a dict - except a non-iterable one...
#InfoMap &ExtraInfo
#ADDONDEPS &GetDeps()  // map of id (str) to pair<AddonVer, 'optional' flag>
%>

static PyGetSetDef pgsScr[] = {
${getdefs()}
  {NULL}  /* Sentinel */
};


// Python type objects

static PyTypeObject ptoTyp = { PyObject_HEAD_INIT(NULL) };  // type constants
static PyTypeObject ptoMps = { PyObject_HEAD_INIT(NULL) };  // string map
static PyTypeObject ptoSet = { PyObject_HEAD_INIT(NULL) };  // settings
static PyTypeObject ptoDep = { PyObject_HEAD_INIT(NULL) };  // dependencies
static PyTypeObject ptoScr = { PyObject_HEAD_INIT(NULL) };  // scraper


PyMODINIT_FUNC
initscraper()
{
  PyImport_ImportModule("xbmc.lib");
  // Unfortunately we have to leak this reference; there's no module cleanup
  // function, and Python APIs can't be called from Py_AtExit.

  InitPto(ptoTyp, "xbmc.scraper.Type", sizeof(EmO), "Scraper types");
  ptoTyp.tp_flags = Py_TPFLAGS_IS_ABSTRACT;

  InitPto(ptoMps, "xbmc.scraper.StringMap", sizeof(MpsO), "Immutable string map");
  ptoMps.tp_flags = Py_TPFLAGS_IS_ABSTRACT;//XXX

  InitPto(ptoSet, "xbmc.scraper.Settings", sizeof(SetO), "Addon settings");
  ptoSet.tp_flags = Py_TPFLAGS_IS_ABSTRACT;//XXX

  InitPto(ptoDep, "xbmc.scraper.Dependencies", sizeof(DepO), "Addon dependencies");
  ptoDep.tp_flags = Py_TPFLAGS_IS_ABSTRACT;//XXX

  InitPto(ptoScr, "xbmc.scraper.Scraper", sizeof(ScrO), "Scraper interface");
  ptoScr.tp_init = (initproc)scr_init;
  ptoScr.tp_dealloc = (destructor)scr_dealloc;
  ptoScr.tp_methods = pmdScr;
  ptoScr.tp_getset = pgsScr;

  if (PyType_Ready(&ptoTyp) < 0 || PyType_Ready(&ptoMps) < 0 || PyType_Ready(&ptoSet) ||
    PyType_Ready(&ptoDep) < 0 || PyType_Ready(&ptoScr) < 0)
  {
    return;
  }

  // Type.T scraper type enumeration
  % for t in 'ALBUMS', 'ARTISTS', 'MOVIES', 'MUSICVIDEOS', 'TVSHOWS':
  PyDict_SetItemString(ptoTyp.tp_dict, "${t}", PyInt_FromLong(ADDON_SCRAPER_${t}));
  % endfor

  PyObject *mod = Py_InitModule("scraper", NULL);
  if (mod == NULL)
    return;

  Py_INCREF(&ptoScr);
  Py_INCREF(&ptoTyp);
  Py_INCREF(&ptoMps);
  Py_INCREF(&ptoSet);
  Py_INCREF(&ptoDep);
  PyModule_AddObject(mod, "Scraper", (PyObject *)&ptoScr);
  PyModule_AddObject(mod, "Type", (PyObject *)&ptoTyp);
  PyModule_AddObject(mod, "StringMap", (PyObject *)&ptoMps);
  PyModule_AddObject(mod, "Settings", (PyObject *)&ptoSet);
  PyModule_AddObject(mod, "Dependencies", (PyObject *)&ptoDep);
}

