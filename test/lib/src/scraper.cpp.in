// Implements xbmc.lib.scraper
//
// *** GENERATED CODE DO NOT EDIT ***
## (applies to the .cpp file, not the .in file...)
//
<%namespace file="defs.mako" import="*"/>

#include "Python.h"
#include "structmember.h"

#include "xbmc.h"
#include "addons/Addon.h"
#include "addons/Scraper.h"
#include "addons/AddonManager.h"
#include "filesystem/FileCurl.h"
#include "video/VideoInfoTag.h"

using namespace std;
using namespace ADDON;


// Python type objects

static PyTypeObject ptoTyp = { PyObject_HEAD_INIT(NULL) };  // type constants
static PyTypeObject ptoMps = { PyObject_HEAD_INIT(NULL) };  // string map
static PyTypeObject ptoSet = { PyObject_HEAD_INIT(NULL) };  // settings
static PyTypeObject ptoDep = { PyObject_HEAD_INIT(NULL) };  // dependencies
static PyTypeObject ptoScr = { PyObject_HEAD_INIT(NULL) };  // scraper


// Empty object
// - used by type container (ptoTyp)
struct EmO
{
  PyObject_HEAD
};

// Python scraper object
struct ScrO
{
  PyObject_HEAD
  ScraperPtr psc;
};

// Python immutable string map
struct MpsO
{
  PyObject_HEAD
  ScrO *pscro;
  const InfoMap *pmp;
  InfoMap::const_iterator i;
};

// Python settings object
// NOTE: must remain binary compatible with MpsO!
struct SetO
{
  PyObject_HEAD
  ScrO *pscro;
  const SETTINGS *pset;
  SETTINGS::const_iterator i;
};

// Python dependencies object
struct DepO
{
  PyObject_HEAD
  PyObject *pscro;
  ADDONDEPS *pdep;
};


// Utility functions

// passed-in object assumed to be zero-initialized already
static void InitPto(PyTypeObject &pto, const char *sName, size_t cb, const char *sDoc)
{
  pto.tp_name = sName;
  pto.tp_basicsize = cb;
  pto.tp_doc = sDoc;
  pto.tp_new = PyType_GenericNew;
  pto.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;
}

// raise Python exception for scraper error
PyObject *PyoRaiseSce(const CScraperError &sce)
{
  //XXX get our own exception
  if (sce.FAborted())
    PyErr_SetString(PyExc_RuntimeError, "scraper aborted");
  else
    PyErr_SetString(PyExc_RuntimeError, "CScraperError");
  return NULL;
}


// Scraper object implementation

static int scr_init(ScrO *pscro, PyObject *args, PyObject *kwds)
{
  // parse arguments: scraper type (Type.T) or name (e.g., "metadata.tvdb.com")
  if (kwds && PyDict_Size(kwds))
  {
    PyErr_SetString(PyExc_TypeError, "unexpected keyword argument");
    return -1;
  }

  TYPE typ = ADDON_UNKNOWN;
  const char *sName = NULL;
  if (!PyArg_ParseTuple(args, "i", &typ))
  {
    if (!PyArg_ParseTuple(args, "s", &sName))
    {
      PyErr_SetString(PyExc_TypeError, "scraper type or name required");
      return -1;
    }
    PyErr_Clear();
  }

  // fetch the addon from the addon manager
  AddonPtr pao;
  if (sName)
  {
    if (!CAddonMgr::Get().GetAddon(sName, pao))
    {
      PyErr_SetString(PyExc_RuntimeError, "scraper not found");
      return -1;
    }
  }
  else if (!CAddonMgr::Get().GetDefault(typ, pao))
  {
    PyErr_SetString(PyExc_RuntimeError, "default scraper unavailable");
    return -1;
  }

  // cast to scraper and store
  pscro->psc = boost::dynamic_pointer_cast<CScraper>(pao);
  return 0;
}

static void scr_dealloc(ScrO *pscro)
{
  pscro->~ScrO();
}

static PyObject *scr_nfo_url(ScrO *pscro, PyObject *ppyo)
{
  // verify and convert passed-in string
  const char *sIn;
  Py_ssize_t cchIn;
  if (PyString_AsStringAndSize(ppyo, (char **)&sIn, &cchIn) < 0)
    return NULL;
  CStdString s(sIn, cchIn);

  try
  {
    CScraperUrl scurl = pscro->psc->NfoUrl(s);
    if (scurl.m_url.empty())
      Py_RETURN_NONE;
    //XXX return a proper object!
    CStdString &sRet = scurl.m_url.begin()->m_url;
    return PyString_FromStringAndSize(sRet, sRet.size());
  }
  catch(const CScraperError &sce)
  {
    return PyoRaiseSce(sce);
  }
}

//XXX need a way to set fcurl (globally, or in the object?)...
//also need a scraper object
//and a scraper exception/abort (two separate Python exceptions?)

static PyMethodDef pmdScr[] = {
  {"nfo_url", (PyCFunction)scr_nfo_url, METH_O,
    "Given the contents of a .nfo file, returns an URL (None if none found)" },

/*
  {"find_movie", (PyCFunction)scr_find_movie, METH_VARARGS,
    "Find a movie given the title; replace special chars if clean is True" },
  {"find_album", (PyCFunction)scr_find_album, METH_VARARGS,
    "Find an album given the title and optional artist" },
  {"find_artist", (PyCFunction)scr_find_artist, METH_O,
    "Find an artist given a name" },

 * XXX really these should be called on the object returned from the above...
 * ... art_details should store the search string on return so it can be autopassed
 * ... they can also be given fcurl and scurl will be implicit from the object
  {"episodes", (PyCFunction)vid_episodes, METH_NOARGS,
    "Get episode list" },
  {"details", (PyCFunction)vid_details, METH_NOARGS,
    "Get video details" },
  {"details", (PyCFunction)alb_details, METH_NOARGS,
    "Get album details" },
  {"details", (PyCFunction)art_details, METH_NOARGS,
    "Get artist details" },
*/
#if 0
  // scraper media functions

  std::vector<CScraperUrl> FindMovie(XFILE::CFileCurl &fcurl,
    const CStdString &sMovie, bool fFirst);
  std::vector<MUSIC_GRABBER::CMusicAlbumInfo> FindAlbum(XFILE::CFileCurl &fcurl,
    const CStdString &sAlbum, const CStdString &sArtist = "");
  std::vector<MUSIC_GRABBER::CMusicArtistInfo> FindArtist(
    XFILE::CFileCurl &fcurl, const CStdString &sArtist);
  EPISODELIST GetEpisodeList(XFILE::CFileCurl &fcurl, const CScraperUrl &scurl);

  bool GetVideoDetails(XFILE::CFileCurl &fcurl, const CScraperUrl &scurl,
    bool fMovie/*else episode*/, CVideoInfoTag &video);
  bool GetAlbumDetails(XFILE::CFileCurl &fcurl, const CScraperUrl &scurl,
    CAlbum &album);
  bool GetArtistDetails(XFILE::CFileCurl &fcurl, const CScraperUrl &scurl,
    const CStdString &sSearch, CArtist &artist);
#endif
  {NULL}  /* Sentinel */
};

<%
add_get('type', 'Type', 'int', "Scraper type, from Type enumeration")
add_get('id', 'ID', 'CStdString', "Scraper id (dotted pseudo-domain)")
add_get('name', 'Name', 'CStdString', "Scraper display name")
add_get('enabled', 'Enabled', 'bool', "True if scraper is currently enabled")
add_get('active', 'IsInUse', 'bool', "True if scraper is currently running")
add_get('ver', 'Version', 'AddonVersion', "Scraper version (NOT COMPARABLE)")
add_get('min_ver', 'MinVersion', 'AddonVersion', "Minimum compatible version")
add_get('summary', 'Summary', 'CStdString', "Scraper summary")
add_get('desc', 'Description', 'CStdString', "Scraper description")
add_get('path', 'Path', 'CStdString', "Path to scraper files")
add_get('profile', 'Profile', 'CStdString', "Path to profile-local data")
add_get('lib_path', 'LibPath', 'CStdString', "Path to addon library")
add_get('changelog', 'ChangeLog', 'CStdString', "Scraper change log")
add_get('fanart', 'FanArt', 'CStdString', "Fan art path")
add_get('author', 'Author', 'CStdString', "Scraper developer")
add_get('icon', 'Icon', 'CStdString', "Path to scraper icon")
add_get('rating', 'Stars', 'int', "Rating (0-5 stars)")
add_get('disclaimer', 'Disclaimer', 'CStdString', "Disclaimer text")
add_get('lang', 'Language', 'CStdString', "Scraper language")
add_get('has_settings', 'HasSettings', 'bool', "True if scraper has custom settings")

#
#ADDONDEPS &GetDeps()  // map of id (str) to pair<AddonVer, 'optional' flag>
%>

static PyObject *scr_get_mps_extra_info(ScrO *pscro, void *)
{
  return (PyObject *)PyObject_CallFunctionObjArgs((PyObject *)&ptoMps, pscro, NULL);
}

static PyObject *scr_get_set_settings(ScrO *pscro, void *)
{
  return (PyObject *)PyObject_CallFunctionObjArgs((PyObject *)&ptoSet, pscro, NULL);
}

static PyGetSetDef pgsScr[] = {
${getdefs()}
  {"extra_info", (getter)scr_get_mps_extra_info, NULL, "Extra info dictionary", NULL},
  {"settings", (getter)scr_get_set_settings, NULL, "Addon settings", NULL},
  {NULL}  /* Sentinel */
};


// String map (std::map<CStdString, CStdString>) object implementation

static ScrO *ScroMapInit(PyObject *args, PyObject *kwds)
{
  if (kwds && PyDict_Size(kwds))
  {
    PyErr_SetString(PyExc_TypeError, "unexpected keyword argument");
    return NULL;
  }

  ScrO *pscro = NULL;
  if (!PyArg_ParseTuple(args, "O", &pscro))
  {
    PyErr_SetString(PyExc_TypeError, "scraper object required");
      return NULL;
  }
  Py_INCREF(pscro);
  return pscro;
}

static int mps_init(MpsO *pmpso, PyObject *args, PyObject *kwds)
{
  ScrO *pscro = ScroMapInit(args, kwds);
  if (pscro == NULL)
    return -1;
  pmpso->pscro = pscro;
  pmpso->pmp = &pscro->psc->ExtraInfo();
  return 0;
}

static void mps_dealloc(MpsO *pmpso)
{
  Py_XDECREF(pmpso->pscro);
  pmpso->~MpsO();
}

static PyObject *mps_iter(MpsO *pmpso)
{
  pmpso->i = pmpso->pmp->begin();
  Py_INCREF(pmpso);
  return (PyObject *)pmpso;
}

static PyObject *mps_iternext(MpsO *pmpso)
{
  if (pmpso->i == pmpso->pmp->end())
    return NULL;
  const CStdString &sKey = pmpso->i->first;
  const CStdString &sVal = pmpso->i->second;
  ++pmpso->i;
  PyObject *tup = PyTuple_New(2);
  PyTuple_SetItem(tup, 0, PyString_FromStringAndSize(sKey, sKey.size()));
  PyTuple_SetItem(tup, 1, PyString_FromStringAndSize(sVal, sVal.size()));
  return tup;
}

static Py_ssize_t mps_length(MpsO *pmpso)
{
  return pmpso->pmp->size();
}

static PyObject *mps_subscript(MpsO *pmpso, PyObject *key)
{
  const char *s = PyString_AsString(key);
  if (!s)
    return NULL;
  InfoMap::const_iterator i = pmpso->pmp->find(s);
  if (i == pmpso->pmp->end())
  {
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  return PyString_FromStringAndSize(i->second, i->second.size());
}

static PyMappingMethods pmmMps =
{
  (lenfunc)mps_length,
  (binaryfunc)mps_subscript,
  NULL  // no assignment
};


// Settings object implementation

static int set_init(SetO *pseto, PyObject *args, PyObject *kwds)
{
  ScrO *pscro = ScroMapInit(args, kwds);
  if (pscro == NULL)
    return -1;
  pseto->pscro = pscro;
  pseto->pset = &pscro->psc->GetSettings();
  return 0;
}

static int set_assign(SetO *pseto, PyObject *key, PyObject *val)
{
  const char *sKey, *sVal;
  Py_ssize_t cchKey, cchVal;
  if (PyString_AsStringAndSize(key, (char **)&sKey, &cchKey) < 0 ||
    PyString_AsStringAndSize(val, (char **)&sVal, &cchVal) < 0)
  {
    return -1;
  }
  pseto->pscro->psc->UpdateSetting(CStdString(sKey, cchKey), CStdString(sVal, cchVal));
  return 0;
}

static PyObject *set_save(SetO *pseto, PyObject *ppyo)
{
  pseto->pscro->psc->SaveSettings();
  Py_RETURN_NONE;
}

static PyMappingMethods pmmSet =
{
  (lenfunc)mps_length,
  (binaryfunc)mps_subscript,
  (objobjargproc)set_assign
};

static PyMethodDef pmdSet[] = {
  {"save", (PyCFunction)set_save, METH_NOARGS, "Save settings" },
  {NULL}  /* Sentinel */
};


// Module initialization

PyMODINIT_FUNC
initscraper()
{
  PyImport_ImportModule("xbmc.lib");
  // Unfortunately we have to leak this reference; there's no module cleanup
  // function, and Python APIs can't be called from Py_AtExit.

  InitPto(ptoTyp, "xbmc.scraper.Type", sizeof(EmO), "Scraper types");
  ptoTyp.tp_flags = Py_TPFLAGS_IS_ABSTRACT;

  InitPto(ptoMps, "xbmc.scraper.StringMap", sizeof(MpsO), "Immutable string map");
  ptoMps.tp_flags |= Py_TPFLAGS_HAVE_ITER;
  ptoMps.tp_init = (initproc)mps_init;
  ptoMps.tp_dealloc = (destructor)mps_dealloc;
  ptoMps.tp_as_mapping = &pmmMps;
  ptoMps.tp_iter = (getiterfunc)mps_iter;
  ptoMps.tp_iternext = (iternextfunc)mps_iternext;

  InitPto(ptoSet, "xbmc.scraper.Settings", sizeof(SetO), "Addon settings");
  ptoSet.tp_flags |= Py_TPFLAGS_HAVE_ITER;
  ptoSet.tp_init = (initproc)set_init;
  ptoSet.tp_dealloc = (destructor)mps_dealloc;
  ptoSet.tp_as_mapping = &pmmSet;
  ptoSet.tp_iter = (getiterfunc)mps_iter;
  ptoSet.tp_iternext = (iternextfunc)mps_iternext;
  ptoSet.tp_methods = pmdSet;

  InitPto(ptoDep, "xbmc.scraper.Dependencies", sizeof(DepO), "Addon dependencies");
  ptoDep.tp_flags = Py_TPFLAGS_IS_ABSTRACT;//XXX

  InitPto(ptoScr, "xbmc.scraper.Scraper", sizeof(ScrO), "Scraper interface");
  ptoScr.tp_init = (initproc)scr_init;
  ptoScr.tp_dealloc = (destructor)scr_dealloc;
  ptoScr.tp_methods = pmdScr;
  ptoScr.tp_getset = pgsScr;

  if (PyType_Ready(&ptoTyp) < 0 || PyType_Ready(&ptoMps) < 0 || PyType_Ready(&ptoSet) ||
    PyType_Ready(&ptoDep) < 0 || PyType_Ready(&ptoScr) < 0)
  {
    return;
  }

  // Type.T scraper type enumeration
  % for t in 'ALBUMS', 'ARTISTS', 'MOVIES', 'MUSICVIDEOS', 'TVSHOWS':
  PyDict_SetItemString(ptoTyp.tp_dict, "${t}", PyInt_FromLong(ADDON_SCRAPER_${t}));
  % endfor

  PyObject *mod = Py_InitModule("scraper", NULL);
  if (mod == NULL)
    return;

  Py_INCREF(&ptoScr);
  Py_INCREF(&ptoTyp);
  Py_INCREF(&ptoMps);
  Py_INCREF(&ptoSet);
  Py_INCREF(&ptoDep);
  PyModule_AddObject(mod, "Scraper", (PyObject *)&ptoScr);
  PyModule_AddObject(mod, "Type", (PyObject *)&ptoTyp);
  PyModule_AddObject(mod, "StringMap", (PyObject *)&ptoMps);
  PyModule_AddObject(mod, "Settings", (PyObject *)&ptoSet);
  PyModule_AddObject(mod, "Dependencies", (PyObject *)&ptoDep);
}

